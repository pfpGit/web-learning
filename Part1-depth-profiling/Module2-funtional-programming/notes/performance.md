# 性能优化
- 网络相关
  - DNS预解析
  - 缓存
  - HTTP/2.0
  - 预加载
  - 预渲染
- 优化渲染过程
  - 懒执行
  - 懒加载
- 文件优化
  - 图片优化
  - 其他文件优化
  - CDN
- 其他
  - 使用webpack优化项目
  - 监控
- JavaScript性能优化
  - 内存管理
  - 垃圾回收
  - 常见GC算法
  - V8引擎的垃圾回收
  - performance工具分析
  - 代码层面的优化-缓存，局部变量




## JavaScript性能优化
---


### 内存管理
- 内存：由可读写单元组成，即可操作空间
- 管理：人为的操作空间的申请、使用和释放
- 管理流程：申请-使用-释放



### 垃圾回收
- JavaScript内存是自动管理的
- 对象不被引用时被认为垃圾
- 对象不能在根上访问到时是垃圾

可达对象
- 可以访问到的对象就是可达对象（引用、作用域链）
- 可达的标准就是从根出发是否能够被找到
- JavaScript中的根可以理解为全局变量对象



### GC算法
- GC就是垃圾回收机制的简写
- GC可以找到内存中的垃圾、然后释放和回收空间

GC里的垃圾是什么
```js
// 程序中不需要使用的对象
function func(){
    name = 'pfp'
    return name
}
```
```js
// 程序中不需要使用的对象
function func(){
    const name = 'pfp'
    return name
}
```

常用的GC算法
- 引用计数-通过计数判断垃圾
- 标记清除-给活动对象添加标记，判断是否是垃圾
- 标记整理-类似标记清除，区别在于回收垃圾时，会对内存做重新分配，方便内存管理
- 分代回收-v8中会使用到

引用计数算法
- 核心思想：通过引用计数器统计对象引用数，判断当前引用数是否为0，作为垃圾的依据
- 引用数为0时立即回收

引用计数算法优点
- 发现垃圾立即回收
- 最大限度减少程序暂停

引用计数缺点
- 无法回收循环引用对象
- 时间开销大（时刻监控引用数）

标记清除算法实现原理
- 核心思想：分`标记`和`清除`两个阶段完成
  - 遍历所有对象找标记活动对象
  - 遍历所有对象清除没有标记的对象
  - 回收相应的空间

- 优点：
  - 可以回收局部循环引用的对象
  
- 缺点：
  - 空间碎片化，无法最大化的利用内存空间


标记整理算法（标记清除算法的增强）
- 原理：
  - 标记阶段的操作和标记清除一致
  - 清除阶段会先执行内存整理，移动对象位置，避免内存空间碎片化


GC算法总结

- 引用计数
  - 优点：
    - 及时回收垃圾
    - 减少程序卡顿
  - 缺点：
    - 无法回收循环引用对象
    - 资源消耗较大（引用计数器）
- 标记清除
  - 优点：
    - 可以回收循环引用对象
  - 缺点：
    - 容易产生碎片化空间，浪费内存
    - 不会立即回收垃圾对象
- 标记整理
  - 优点
    - 可以清除循环引用对象
    - 可以解决垃圾回收后造成的空间碎片化问题
  - 缺点
    - 不会立即回收垃圾对象



### v8
- V8是当前主流的JavaScript执行引擎
- V8内存设置上限（1.5G和800M）
  - 垃圾回收机制决定了上限不能超过用户感知的大小
  - 针对web应用设计合理
- V8采用基于分代回收思想实现垃圾回收
  - 新生代（32M和16M）
    - 新生代空间存储存活时间较短的对象
    - 回收过程采用复制算法+标记整理
    - 新生代空间分等大的空间from和to，from用于存储活动对象
    - 标准整理后将活动对象copy到to
      - 经过一轮GC还存活的新生代对象会移动到老生代空间（晋升）
      - to空间使用率超过25%
    - from与to交换空间完成释放垃圾
  - 老生代
    - 内存大小（1.4G/700M）
    - 老生代存储空间用于存储存活时间较长的对象
    - 主要采用标记清除、标记整理、增量标记算法
    - 主要采用标记清除回收垃圾
    - 当新生代的对象移动到老生代时，内存不足会触发标记整理算法
