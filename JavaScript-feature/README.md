# 裴繁鹏 ｜ ES新特性与js异步编程 | 模块一

## 一、简答题

### 第1题

> 最终执行结果为：打印出 10。

原因是: for循环中无法形成块级作用域，函数中的i随着循环被改变，遍历完i的值变为了10；


### 第2题

> 执行结果为：Uncaught ReferenceError;

原因是：if里面形成了一个块级作用域，tmp打印在let声明之前，所以出现未申明就使用的错误；


### 第3题

```js
// es6的方式查找最小值
var arr = [12, 34, 32, 89, 4]
Math.min(...arr)
```


### 第4题
- var在相同的作用域中可以重复声明，可以未声明就使用
- let和var声明赋值后还可以改变值，可以声明不初始化值
- const声明的变量必须有初始值，并且不能改变变量的值
- 同一个作用域，let和const不能重复声明，不可以声明已经存在的变量


### 第5题

> 执行结果为：输出20;

原因是：
- setTimeout是箭头的回调函数，箭头函数中的this指向执行环境，此时的执行环境为obj.fn函数作用域
- obj.fn的this指向obj，所以this.a为obj.a


### 第6题

- 作为object独一无二的key
- 独一无二的变量

### 第7题

- 浅拷贝相对于深拷贝而言，浅拷贝只复制了第一层属性值，当属性值为对象时，没有进一步的拷贝，导致拷贝后的对象和原来的对象的值都指向了相同的对象哈希值，有一个值改变后，另外一个也会改变
- 深拷贝会根据所有的属性值是否为基础类型，做简单的复制或递归复制，保证拷贝后的对象和原来的对象改变某个属性后不会相互影响


### 第8题

- js异步编程是因为js的执行过程是单线程的，为保证某些耗时的操作不阻塞线程，造成假死状态，js把耗时的操作放到任务队列里面，等到执行栈执行完后，再把任务队列中的事件取出来放到执行栈中执行，此时可能会渲染dom
- 当执行栈中又有事件执行，会重复原来的过程，这就是EventLoop
- 宏任务有setTimeout,setInterval,dom事件等
- 微任务如promise


### 第9题
```js
const sleep = (time)=> new Promise((resolve)=>{
    setTimeout(resolve,time)
})

async function say(){
    await sleep(10);
    var a = 'hello';
    await sleep(10);
    var b = 'lagou';
    await sleep(10);
    var c = 'I love U';
    console.log(a+b+c)
}

say()
```

### 第10题
TypeScript是JavaScript类型的超类，它可以编译成纯JavaScript

### 第11题

优点：
- 因为ts是强类型语言，可以在开发时就可以看到可能的报错，避免了生产运行时才可能出现的错误
- ts的变量和接口约束作用可以有更好的提示，方便开发，也更好的规避错误的出现

不足：
- 新增了很多特性和接口，需要学习更多的内容，需要时间上手
- 有些库可能还没有现成的接口声明文件，需要手动声明